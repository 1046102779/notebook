### [阿里架构](https://github.com/davideuler/architecture.taobao-alibaba/blob/b8bb7bf3046026722cbe536f47ee5bd87a9d7e92/2017%20%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E5%B9%B4%E5%BA%A6%E7%B2%BE%E9%80%89%20Alitech%20Archive_1.pdf)
《破解世界性技术难题！GTS让分布式事务简单高效》一文，在分布式或者微服务流行的今天，一个外部的请求可能会调用多个服务。分布式事务就是为了保证某个服务出错时，能保证数据的一致性，这个请求的所有服务操作，要么全部成功、要么全部失败。

**本质上来说，分布式事务就是为了保证不同数据库或者消息系统的数据一致性**

分布式事务三大难题：
1. 数据一致性
2. 高性能
3. 易用性

一般情况都是，确保数据一致性所付出的成本代价高昂，会损耗掉高性能和易用性。前者：由于处理数据一致性，导致业务逻辑过于繁琐，性能地下、且业务代码生涉难懂。

但是如果三者缺一，则使用场景大大受限，实用价值不高。
1. 数据一致性。要求在各种异常情况下保证数据是强一致的，目前最常见的一致性解决方案是最终一致性方案，例如：分布式系统中的CAP理论，三个特性不能同时满足的情况下，P是肯定满足，CA二者选其一，我们一般都会选择高可用的情况，保证数据的最终一致性，这样就能够间接满足CAP理论。为了实现数据的最终一致性，通常是结合消息中间件实现。
2. 高性能：目前基于XA协议的两阶段提交时最常见的分布式事务解决方案。但是XA类产品的典型不足时性能低下，往往不能接受。
3. 易用性：为了满足一致性和高性能要求，出现了一些特定场景下的分布式事务方案，但是一般都会对业务侵入强，无法做到简单易用，成本高。

阿里针对世界级应用场景，提出了[世界级分布式事务解决方案-GTS](https://www.cnblogs.com/jiangyu666/p/8522547.html), 该项目负责人姜宇。该文指出了微服务下分布式事务目前已存在的解决方案：
1. 基于XA协议的2PC(两阶段提交)方案
    ```shell
    两阶段提交，分别是：表决阶段和执行阶段。两阶段提交方案应用很广泛，几乎所有OLTP数据库都支持XA协议，但是两阶段提交方案锁定资源时间长，对性能影响很大，基本上不适合解决微服务事务问题
    ```
2. TCC方案
    ```shell
    TCC(Try-Confirm-Cancel)方案，它是两阶段提交的一种改进。 Try：完成业务的准备工作，Confirm：完成业务的提交，Cancel：完成事务的回滚。
    事务协调器会根据Try的执行返回结果，然后决定调用Confirm或者Cancel接口。
    TCC方案可以定义自己的数据锁粒度，降低锁冲突，提高并发吞吐量成为可能。但是它的不足之处在于：
    1. 对应用的侵入性强。业务逻辑的每个分支都要实现try、confirm和cancel三个操作，业务侵入性强，改造成本高；
    2. 实现难度较大。需要根据网络状态、系统故障等不同的失败原因，实现不同的回滚策略。为了满足一致性要求，confirm和cancel接口必须实现幂等。
    ```
3. 基于消息的最终一致性方案
    ```shell
    消息一致性方案是通过消息中间件保存上下服务数据操作的一致性。基本思路：将本地操作和发送消息放在一个事务中，保证本地操作和消息发送操作，要么两者都成功或者失败。下游收到消息后执行相应操作。
    消息方案从本质上来说，是将分布式事务转换为两个事务，然后依靠下游业务的重试机制达到最终一致性，这个改进在于下游的事务操作失败后，还可以通过消息中间件进行事务补偿，从而达到数据的最终一致性。
    缺点：基于消息的最终一致性方案对应用的侵入性也很高，应用需要进行大量的业务改造，成本高。
    ```
4. GTS —— 阿里分布式事务解决方案
    ```shell
    特点：
    1. 性能超强
    2. 应用侵入性极低
    3. 完整解决方案
    4. 容错能力强
    
    GTS包括客户端Client、Server事务协调器和资源管理器(RM):
    GTS Client主要用来确定事务边界，完成事务的发起和结束
    GTS RM完成事务分支的创建、提交和回滚等操作（它存在于每个微服务中，类似于agent）
    GTS Server主要负责分布式事务的整体推进和事务生命周期管理
    ```

《如何打造支撑百万用户的分布式代码托管平台?》一文，Gitlab不满足SaaS设计[12原则](https://12factor.net/zh_cn/)的第四条：后端服务-把后端服务当做附加资源。大家可以认真理解下这12原则，对大家以后的SaaS微服务设计非常有帮助。
```shell
1. 基准代码——一份基准代码，多份部署
    基准代码与应用之间总是保持一一对应的关系：
    一方面，如果一个应用有多个基准代码，则是分布式系统。另一方面，多个应用共享一份基准代码，则需要分为独立的类库
2. 依赖——显式声明依赖关系
    该规则不会隐式依赖系统级的类库。它一定是通过依赖清单，确切地声明所有依赖项， 这个做法会统一应用到开发、测试和生产环境中。
    例如：包管理dep初始化代码库的依赖包时，它会生成Gopkg.toml， 这里面存放着所有依赖包和包的当前版本号，显示声明所有依赖，同时也方便了库的下载和版本号导致的编译错误或者不稳定。
3. 配置——在环境中存储配置
    这个是非常常见的做法，同一份代码，通过取环境变量，来指定当前的服务环境（开发、测试和生产环境），以及服务配置中心的db、cache、dns或者其他参数的value，这个是非常重要的，做到了去代码依赖。
4. 后端服务——把后端服务当做附加资源
    12原则应用不会区分对待本地和第三方应用，例如：本地mysql服务和第三方AWS上的RDS服务，我们只需要通过获取配置中心的db服务配置，就可以进行db存储操作。（而gitlab违反了这一设计的主要原因在于：1. 数据存储于服务器本地的文件系统上；2.gitlab所依赖的三个重要组件：libgit2, git, grit也都是直接操作在文件系统上。由此当gitlab的数据存储出现容量和负载瓶颈时，难以扩容！）
5. 构建、发布和运行——严格分离构建和运行
6. 进程——以一个或者多个无状态进程运行应用
    12原则应用的进程必须是无状态且无共享。任何需要持久化的数据都要存储在后端服务内，比如数据库。
    无状态进程或者服务，则在负载弹性伸缩方面变得简单。同时服务编排也变得简单可行。例如：serverless的k8s, mesos等服务编排工具
7. 端口绑定——通过端口绑定来提供服务
    12原则应用完全自我加载而不依赖于任务网络服务器就可以创建一个面向网络的服务。web应用通过端口绑定来提供服务， 并监听发送到该端口的所有请求。
8. 并发——通过进程模型进行扩展
    它主要是借鉴unix守护进程模型, 开发人员可以根据不同工作进行进程分类。例如：典型的Nginx(master nginx和worker nginx)，或者中心化集群(master node , slave node)。这样master进程只做消息、元素同步和代理转发工作， 实际的业务处理通过worker计算节点做，这样通过业务请求分发模式，使得业务计算量扩容简单方便，同时进程的守护通过supervisor守护。
9. 易处理——快速启动和优雅终止可最大化健壮性
    这个易处理原则，意思是进程可以瞬间开启或者停止。这样服务可以快速扩容或者缩容，迅速部署稳健的服务。
    1. 典型的切流量，如果服务冷启动过慢，则对用户而言，服务是可感知有损的
    2. 某个区域服务节点宕机时，网关服务必须立即停止服务，不能接入新的流量进来。新的流量无法被正确处理。
10. 开发环境与线上环境等价——尽可能地保持开发、预发布、线上环境相同
    一般来说开发环境和线上环境的代码库会存在一些差异，主要表现：
    1. 时间差异：开发环境可能正在开发新功能，线上环境的代码比开发环境老；
    2. 人员差异：开发所需要的资源和线上的资源不一样，生产环境的数据存储、配置中心等和开发环境不一样；部署策略可能也不一样
    3. 工具差异：开发环境可能部署工具、服务监控、metrics指标等都和生产环境不一样。开发环境的资源比较集中、而生产环境的资源是开发不可控的， 以及日志处理等
11. 日志——把日志当做事件流
    该原则是指服务本身不关心日志的存储容量、位置、日志分析，它只是调用一个日志组件或者方法，提供日志内容。
12. 管理进程——后台任务管理当做一次性进程运行
    该原则是指，进程的无状态，以及进程挂掉后的服务高可用的保证。如果采用docker，则可以通过各种服务编排工具实现；否则，可以通过supervisor来实现进程down时，自动拉起。
```
